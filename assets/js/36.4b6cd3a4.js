(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{1926:function(e,s,a){e.exports=a.p+"assets/img/1642576572603.e4301ab1.png"},1927:function(e,s,a){e.exports=a.p+"assets/img/1642571567318.2508384c.png"},1928:function(e,s,a){e.exports=a.p+"assets/img/1642572556316.6c63637d.png"},1929:function(e,s,a){e.exports=a.p+"assets/img/1642577785428.e0033184.png"},1930:function(e,s,a){e.exports=a.p+"assets/img/1642577874812.e35ec594.png"},1931:function(e,s,a){e.exports=a.p+"assets/img/1642578152760.2a9e24a7.png"},1932:function(e,s,a){e.exports=a.p+"assets/img/1642581931405.27655197.png"},1933:function(e,s,a){e.exports=a.p+"assets/img/2022-01-1917.34.16.4bff8984.png"},1934:function(e,s,a){e.exports=a.p+"assets/img/2022-01-2109.23.03.a372faa2.png"},1935:function(e,s,a){e.exports=a.p+"assets/img/2022-01-2109.28.48.5f3d9951.png"},1936:function(e,s,a){e.exports=a.p+"assets/img/2022-01-2110.00.27.3a0c79b6.png"},1937:function(e,s,a){e.exports=a.p+"assets/img/2022-01-2110.07.58.957786c1.png"},2737:function(e,s,a){"use strict";a.r(s);var n=a(9),t=Object(n.a)({},(function(){var e=this,s=e.$createElement,n=e._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"一-b-tree"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一-b-tree"}},[e._v("#")]),e._v(" 一：B-Tree")]),e._v(" "),n("h3",{attrs:{id:"一-b-tree的由来"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一-b-tree的由来"}},[e._v("#")]),e._v(" (一)：B-Tree的由来")]),e._v(" "),n("ul",[n("li",[e._v("由于二分搜索树、AVL平衡树、红黑树如果是存储磁盘数据，"),n("strong",[e._v("那么每个节点存储一个数据，会使得树的高度非常高")]),e._v("，那么在树的操作过程中就会使得树的开销特别大，因此引入B-Tree。B-Tree是在二叉树、平衡二叉树等基础上演变而来的，"),n("strong",[e._v("为适用于磁盘等外存存储而设计的的多路平衡查找树")]),e._v("。在下图的B-Tree中，"),n("strong",[n("code",[e._v("每个节点包含Key、Value、指向下一个节点的指针")])])])]),e._v(" "),n("p",[n("img",{attrs:{src:a(1926),alt:"Alt text"}})]),e._v(" "),n("ul",[n("li",[e._v("B-Tree是一种平衡的多路查找树，2-3树和2-3-4树都是B-Tree的特例，在多路查找树中，"),n("strong",[e._v("所有节点的"),n("code",[e._v("子节点个数")]),e._v("的最大值称为"),n("code",[e._v("B-Tree的阶")]),e._v("，记为M")]),e._v("。一个M阶的B-Tree要么是空树，要么是M叉树。B-Tree的性质如下：")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("1：M阶B-Tree，每个节点最多可以包含M-1个Key(Data)和M个子节点。例如下图中，M为3，是一个3叉树，那么非叶子节点可以包含的Key最多是3-1=2个，例如节点【29,32】。节点【29,32】有3个子节点，分别是【10,23】、【30,31】、【45,58】\n\n2：除了根节点和叶节点之外，B-Tree中的每个节点至少包含m/2个子节点。例如下图中，节点【29,32】包含3个子节点，满足3/2=1的要求\n\n3：根节点必须至少具有两个子节点。例如下图中，根节点【60】有两个子节点，分别为节点【29,32】、节点【90,98】\n\n4：所有叶子节点必须处于同一深度。例如下图中，所有的叶子节点都在同一个深度，类似2-3树\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br")])]),n("p",[n("img",{attrs:{src:a(1927),alt:"Alt text"}})]),e._v(" "),n("h3",{attrs:{id:"二-b-tree的查询操作"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二-b-tree的查询操作"}},[e._v("#")]),e._v(" (二)：B-Tree的查询操作")]),e._v(" "),n("p",[n("img",{attrs:{src:a(1928),alt:"Alt text"}})]),e._v(" "),n("ul",[n("li",[e._v("B-Tree的查询过程与二分搜索树类似，例如查询一个value为49的节点，"),n("code",[e._v("那么就需要遍历B-Tree，例如使用前序遍历的方式遍历")])])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("1：49小于78，从左子树开始查找\n\n2：49在40与56之间，且大于40，小于56，那么从40的由子树中查找\n\n3：49大于45，那么向后移动，找到value为49的节点，然后返回\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br")])]),n("h3",{attrs:{id:"三-b-tree的插入操作"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三-b-tree的插入操作"}},[e._v("#")]),e._v(" (三)：B-Tree的插入操作")]),e._v(" "),n("ul",[n("li",[e._v("B-Tree的插入操作与二分搜索树的插入类似，新值也是插入到叶子节点中，但是在插入过程中可能不是作为节点插入，而是作为值插入到某个节点上，需要满足如下规则：")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("1：按照二分搜索树的插入节点规则，遍历B-Tree，找到新值适合插入的节点\n\n2：如果适合插入的节点的key个数少于m-1个，那么按照升序规则插入值即可\n\n3：如果适合插入的节点的key个数等于m-1个，那么按照升序规则插入后，将中值元素剔除，插入到当前节点的父节点，当前节点分裂为两个节点，如果父节点插入新值后，key个数大于m个，那么也按照相同步骤进行拆分\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br")])]),n("ul",[n("li",[e._v("假设下图是一个M=5的B-Tree结构，插入一个8的过程如下：")])]),e._v(" "),n("p",[n("img",{attrs:{src:a(1929),alt:"Alt text"}})]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("1：按照二分搜索树的性质，找到了节点【3,5,10,23】适合8插入\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("p",[n("img",{attrs:{src:a(1930),alt:"Alt text"}})]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("2：将8按照升序插入到节点【3,5,10,23】中，当前节点变为【3,5,8,10,23】。根据B-Tree的性质，此时节点【3,5,8,10,23】的key个数为5，大于M-1，那么节点【3,5,8,10,23】就需要被分裂\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("p",[n("img",{attrs:{src:a(1931),alt:"Alt text"}})]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("3：分裂节点【3,5,8,10,23】，将中值8上推至父节点。此时父节点的key个数为3，3小于M-1，因此插入完毕\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("h3",{attrs:{id:"四-b-tree的删除操作"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#四-b-tree的删除操作"}},[e._v("#")]),e._v(" (四)：B-Tree的删除操作")]),e._v(" "),n("ul",[n("li",[e._v("B-Tree删除节点分两种情况")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("1：删除的值位于叶子节点\n\n2：删除的值位于非叶子节点\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br")])]),n("ul",[n("li",[e._v("如果删除的值位于叶子节点，删除按照如下规则")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("1：找值所在到叶子节点\n\n2：如果删除值后，叶子节点中还有m/2个以上的键，则直接从该节点中删除键\n\n3：如果删除值后，叶子节点中没有m/2个以上的键，则通过从左右同级节点中获取键值来满足当前节点的键\n\n4：如果左右兄弟节点均不包含m/2个以上的键，则通过连接两个叶子节点和父节点的中间元素来创建新的叶子节点\n\n5：如果父节点少于m/2个子节点，则也对父节点重复上述过程\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br")])]),n("h3",{attrs:{id:"五-b-tree的应用点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#五-b-tree的应用点"}},[e._v("#")]),e._v(" (五)：B-Tree的应用点")]),e._v(" "),n("ul",[n("li",[e._v("MongoDB索引使用B-Tree数据结构构建的，当基于某个字段对文档进行过滤查询的时候，如果使用了索引，那么就不会全局扫描。"),n("code",[e._v("下面是对key为score创建的索引结构")]),e._v("，在MongoDB中，"),n("strong",[e._v("如果用到了score这个key进行查询过滤document，那么就会使用到B-Tree数据结构构建的索引树，进行查找")]),e._v("。")])]),e._v(" "),n("p",[n("img",{attrs:{src:a(1932),alt:"Alt text"}})]),e._v(" "),n("ul",[n("li",[n("p",[e._v("B-Tree还有对访问局部性原理的利用，"),n("strong",[e._v("是指当一个数据被使用时，其附近的数据有较大概率在短时间内被使用")]),e._v("。"),n("code",[e._v("B-Tree将键相近的数据存储在同一个节点，当访问其中某个数据时，数据库会将该整个节点读到缓存中")]),e._v("；当它临近的数据紧接着被访问时，可以直接在缓存中读取，无需进行磁盘IO。在业务开发之后，我们也使用了"),n("strong",[e._v("局部性原理")]),e._v("来优化读操作，"),n("code",[e._v("当加载第一页数据的同时，也会将第二页的数据 rebuild cache到Redis中，那么读取第二页的数据时，就可以直接从Redis中获取了")])])]),e._v(" "),n("li",[n("p",[e._v("B-Tree数据结构最大的优势就是自平衡，以及始终能够维持多路平衡，"),n("strong",[e._v("在存储较大数据量的同时，降低了树的深度，减少了磁盘的IO次数，提升了数据操作性能")])])])]),e._v(" "),n("h2",{attrs:{id:"二-b-tree"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二-b-tree"}},[e._v("#")]),e._v(" 二：B+Tree")]),e._v(" "),n("h3",{attrs:{id:"一-b-tree与b-tree的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一-b-tree与b-tree的区别"}},[e._v("#")]),e._v(" (一)：B+Tree与B-Tree的区别")]),e._v(" "),n("ul",[n("li",[e._v("B+树也是多路平衡查找树，其与B树的区别主要在于")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("1：B树中每个节点都存储真实的数据，B+树中只有叶子节点存储真实的数据，非叶节点只存储键。在MySQL中，这里所说的真实数据，可能是行的全部数据（如Innodb的聚簇索引），也可能只是行的主键（如Innodb的辅助索引），或者是行所在的地址（如MyIsam的非聚簇索引）\n\n2：B树中一条记录只会出现一次，不会重复出现，而B+树的键则可能重复重现，一定会在叶节点出现，也可能在非叶节点重复出现\n\n3：B+树的叶节点之间通过双向链表链接\n\n4：B树中的非叶节点记录数比子节点个数少1，而B+树中非叶节点key数量与子节点个数相同\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br")])]),n("ul",[n("li",[e._v("下图是B+Tree的数据结构：通常在B+树上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点。因此可以对B+树进行两种查找运算："),n("strong",[e._v("一种是从最小关键字起顺序查找，另一种是从根节点开始，进行随机查找")])])]),e._v(" "),n("p",[n("img",{attrs:{src:a(1933),alt:"Alt text"}})]),e._v(" "),n("ul",[n("li",[e._v("在B+树上进行随机查找、插入和删除的过程基本上与B-树类似。"),n("code",[e._v("但是在随机查找的过程中，如果非叶子节点的key等于查找的值，查询不会停止，会继续向下直到叶子节点，因此在B+Tree的随机查找过程中，都是经过了根节点到叶子节点的查找过程，这样使得B+Tree比B-Tree更加稳定")])])]),e._v(" "),n("h3",{attrs:{id:"二-b-tree在关系型数据库中的应用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二-b-tree在关系型数据库中的应用"}},[e._v("#")]),e._v(" (二)：B+Tree在关系型数据库中的应用")]),e._v(" "),n("ul",[n("li",[e._v("全表扫描：顺序查找")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("最基本的查询算法当然是顺序查找：遍历所有的记录，匹配查找的值是否等于待查找记录的关键字。这个过程的时间复杂度为O(n)，当表的数据量非常大的时候，性能下降很快\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("ul",[n("li",[n("p",[e._v("为了解决顺序查找中，随着数据增大，性能下降很快的问题。"),n("strong",[e._v("数据库引用了索引，索引是数据表之外的一种数据结构，索引对数据表中一个或多个字段进行排序，索引中的key就是每个字段的值")]),e._v("。那么在查询之前，如果给数据表中的某个字段创建了索引，那么查询的时候，会优先查询索引，提升查询效率，索引数据结构一般使用B+Tree存储每个字段值。虽然索引会占用磁盘空间，并且当更新数据库的数据表记录的时候，需要重新创建索引，会带来时间上的开销，但是索引在数据检索速度优势大大超过它的不足之处")])]),e._v(" "),n("li",[n("p",[e._v("为什么数据库会使用B-Tree数据结构，作为索引的实现方式")])])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("1：由于索引的数据量也比较大，无法存储在内存中，只能存储在磁盘上，那么数据库检索数据的时候，就会产生磁盘I/O。相对于内存而言，磁盘的I/O操作需要的时间比内存操作要高出几个数量级，因此查询数据的时候，需要尽量减少磁盘的I/O操作，因此评价一个数据库系统检索数据效率最重要的标准是：一次检索过程中，对磁盘I/O操作的次数。\n基于这个需求，数据库系统引入了局部性原理和磁盘预读，基于局部性原理的定义：当一个数据被用到时，其附近的数据也通常会马上被使用，那么B-Tree结构中，向邻近的key会更可能的存储在同一个节点中，因此数据库搜索到某个key后，也会将其向邻近的key对应的数据也加载到内存，这样有效的提高了磁盘的检索效率。对比于红黑树这样的数据结构而言，B-Tree数据结构在存储相同数量级数据比红黑树的树深度小很多，那么在检索数据的时候，磁盘I/O操作的次数就会少很多\n\n2：B-Tree检索一次数据需要的访问节点的高度为：h=logm/2 (n+1/2)+1，数据库系统使用了磁盘预读的原理，将一个节点的大小设置为内存中page的大小，每个节点只需要一次I/O就可以加载磁盘的一个page的数据到内存中\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br")])]),n("ul",[n("li",[e._v("为什么B+Tree比B-Tree更适合在数据库索引和文件索引中使用")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("1：节点存储key多，IO次数少：B+树中非叶节点key数量与子节点个数相同\n\n2：B+Tree更适合区间访问：B+Tree的叶子节点使用了双向链表，那么当进行访问查询时，可以通过链表指针的方式获取范围内的数据，不需要再次从头检索了，这样加强了区间访问效率。而B-Tree无法进行范围查询，需要重新从根节点查找数据\n\n3：B-Tree只能随机检索，而B+Tree同时支持随机检索 和 顺序检索：B-Tree无法解决元素遍历的效率低下的问题，B+Tree的叶子节点是基于链指针连接的，只需要遍历叶子节点就可以遍历整棵树，因此在范围区间查询上，B+Tree的优势更加明显\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br")])]),n("h3",{attrs:{id:"三-mysql数据库中的b-tree索引"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三-mysql数据库中的b-tree索引"}},[e._v("#")]),e._v(" (三)：MySQL数据库中的B+Tree索引")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("MySQL中常用的引擎有两种："),n("strong",[e._v("MyISAM引擎和InnoDB引擎")]),e._v("，MyISAM引擎和InnoDB引擎虽然都是用的是B+Tree实现的索引结构，但是存储方式截然不同")])]),e._v(" "),n("li",[n("p",[e._v("MyISAM引擎的索引实现方式如下")])])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('1：主键索引：在主键索引中，B+Tree的叶子节点的data域存放的是数据记录的地址\n\n2：辅助索引：主索引和辅助索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复\n\n由于MyISAM引擎的索引是存储的是数据地址，因此MyISAM的索引被称之为"非聚集"，当MySQL使用MyISAM引擎存储引擎的时候，会有两类索引文件：.MYI文件 和 .MYD文件，索引文件和数据文件是分开的\n')])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br")])]),n("ul",[n("li",[e._v("InnoDB引擎的索引实现方式如下")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('1：主键索引：在主键索引中，B+Tree的叶子节点data域保存了完整的数据记录，索引的key就是数据表主键的值，这种索引与数据存储在一起的索引结构称为："聚集索引"。由于InnoDB的索引文件需要按照主键聚集，因此InnoDB要求表必须有主键\n\n2：辅助索引：在辅助索引中，B+Tree的叶子节点data域存储的是普通键+主键，因此在InnoDB存储引擎中，使用辅助索引检索数据需要检索两遍索引，先检索辅助索引，找到主键，再基于主键检索主键索引。因此设置InnoDB存储引擎数据表的主键时，应该使用较短的数据类型，避免索引占用很大存储空间\n\n在InnoDB存储引擎中，设置主键的数据，最好是使用单调的数据。使用非单调的数据作为主键，当插入和删除数据表记录的时候，B+Tree为了保持树的平衡性，会频繁的分裂调整，因此使用自增字段作为主键则是一个很好的选择。因此在使用索引检索数据的时候，最好优先使用主键索引\nInnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读取一条记录的时候，并不是将这个记录本身从磁盘读取出来，而是以页为单位，将整个也加载到内存中，一个页中可能有很多记录，然后在内存中对页进行检索。在innodb中，每个页的大小默认是16kb\n')])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br")])]),n("h2",{attrs:{id:"三-mysql中的b-tree索引"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三-mysql中的b-tree索引"}},[e._v("#")]),e._v(" 三：MySQL中的B+Tree索引")]),e._v(" "),n("h3",{attrs:{id:"一-innodb的聚集索引和非聚集索引"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一-innodb的聚集索引和非聚集索引"}},[e._v("#")]),e._v(" (一)：InnoDB的聚集索引和非聚集索引")]),e._v(" "),n("ul",[n("li",[e._v("聚集索引(主键索引)")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("每个表一定会有一个聚集索引，整个表的数据存储以B+Tree的方式存在文件中，B+Tree叶子节点中的key为主键值，data为完整记录的信息，非叶子节点存储主键的值和子节点的引用\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("ul",[n("li",[e._v("非聚集索引")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("每个表可以有多个非聚集索引，在B+Tree结构中，叶子节点的key为索引字段的值，data为主键的值，非叶子节点只存储索引字段的值和子节点的引用\n\n通过非聚集索引检索记录的时候，可能需要2次操作，先在非聚集索引中检索出主键，然后再到聚集索引中检索出主键对应的记录，该过程比聚集索引多了一次操作。但是如果只需要检索索引字段的值和主键值，那么就不需要第二次操作了，因为第一次操作就可以获取到索引字段的值和主键的值\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br")])]),n("h3",{attrs:{id:"二-sql走了索引还是没有走索引"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二-sql走了索引还是没有走索引"}},[e._v("#")]),e._v(" (二)：SQL走了索引还是没有走索引？")]),e._v(" "),n("ul",[n("li",[e._v("判断SQL查询的时候，是否走了索引，需要进一步理解MySQL构建索引的具体细节。当SQL语句中，对某个字段的值进行检索的时候，如果可以在B+Tree中快速定位到目标数据所在的Page(每个节点就是一个Page)，不需要去扫描所有的数据Page的时候，这样的SQL就是走了索引。如果在SQL中，无法定位到目标数据所在的Page，需要扫描所有的Page，那么这样的SQL就是没有走索引")])]),e._v(" "),n("h3",{attrs:{id:"三-b-tree的检索过程分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三-b-tree的检索过程分析"}},[e._v("#")]),e._v(" (三)：B+Tree的检索过程分析")]),e._v(" "),n("ul",[n("li",[n("strong",[e._v("对唯一索引字段进行检索")]),e._v("：唯一索引字段的值都是唯一的，key=105的检索过程如下")])]),e._v(" "),n("p",[n("img",{attrs:{src:a(1934),alt:"Alt text"}})]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("1：将P1页加载到内存中\n\n2：在内存中使用二分查找算法，可以确定105位于[100,150)中间，所以需要去加载100关联P4页\n\n3：将P4加载到内存中，采用二分法找到105的记录后退出\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br")])]),n("ul",[n("li",[n("strong",[e._v("对普通索引值的检索过程")]),e._v("：普通索引值不是唯一的，才能有重复，例如age=105记录，在数据表中有100条")])]),e._v(" "),n("p",[n("img",{attrs:{src:a(1935),alt:"Alt text"}})]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("1：将P1页加载到内存中\n\n2：在内存中采用二分法查找，可以确定105位于[100,150)中间，100关联P4页\n\n3：将P4加载到内存中，采用二分查找算法到最后一个小于105的记录，即100，然后通过链表从100开始向后访问，找到所有的105记录，直到遇到第一个大于105的值为止\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br")])]),n("ul",[n("li",[n("strong",[e._v("对普通索引范围检索过程")]),e._v("：在B+Tree索引中，"),n("code",[e._v("叶子节点之间是双向链表升序结构，页内部的数据是单项升序链表结构")]),e._v("，因此只要找到范围的起始做在位置，然后通过链表遍历即可找到起始位置中间的所有数据。例如查找age为[55,150]所有记录")])]),e._v(" "),n("p",[n("img",{attrs:{src:a(1936),alt:"Alt text"}})]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("1：将P1页加载到内存\n\n2：内存中采用二分法找算法定位到55位于50关联的P3页中，150位于P5页中\n\n3：将P3加载到内存中，采用二分法找到第一个55的记录，通过链表结构遍历访问P3后续的记录，P3访问完毕后，通过P3的nextpage指针访问下一页P4中所有记录，直到访问到P5中所有的150结束\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br")])]),n("ul",[n("li",[n("strong",[e._v("对索引的模糊匹配检索过程")]),e._v("：在SQL中使用 'f%'，是模糊匹配检索，检索以"),n("code",[e._v("f开头")]),e._v("的所有记录")])]),e._v(" "),n("p",[n("img",{attrs:{src:a(1937),alt:"Alt text"}})]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("1：将P1数据加载到内存中\n\n2：在P1页的记录中采用二分法找到最后一个小于等于f的值，这个值是f，以及第一个大于f的值，这个值是z，f指向叶节点P3，z指向叶节点P6，此时可以断定以f开头的记录可能存在于[P3,P6)这个范围的页内，即P3、P4、P5这三个页中\n\n3：加载P3这个页，在内部以二分法找到第一条f开头的记录，然后以链表方式继续向后访问P4、P5中的记录，即可以找到所有已f开头的数据\n\n注意：如果是使用'%f%'检索，那么无法走索引，因为在P1页中，无法判断包含f的记录在哪些页中，只能加载所有的叶子节点进行遍历查找，因此这种匹配方式无法走索引\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br")])]),n("ul",[n("li",[n("p",[n("strong",[e._v("联合索引的最左匹配原则")]),e._v("：例如创建(name,age,sex)三个字段的联合索引，B+Tree是按照字段从左到右的顺序来构建索引的，当使用"),n("code",[e._v("name='Robby' age=30 sex=M")]),e._v("来检索的时候，B+Tree索引树会优先比较name来确定下一步的所搜方向，然后比较age和sex。但是当使用"),n("code",[e._v("age=30 sex=M")]),e._v("来检索的时候，B+Tree树就不知道下一步该查哪个节点，因此检索就无法走索引")])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("索引区分度")]),e._v("：在数据表中对age和sex都建立了非聚集索引，对应的字段值如下，当SQL为："),n("code",[e._v("where age=4 and sex=1")]),e._v("，那么在B+Tree索引中，会走哪个字段的索引呢？"),n("code",[e._v("会走age字段的索引")]),e._v("，因为age的索引值区分度较高。也可以使用"),n("code",[e._v("explain")]),e._v("对SQL进行分析验证")])])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("age：[1,2,3,4,5,6,7,8,8,9,10]\n\nsex：[1,1,1,1,1,0,0,0,0,0]\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br")])]),n("h3",{attrs:{id:"四-sql中正确的使用索引"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#四-sql中正确的使用索引"}},[e._v("#")]),e._v(" (四)：SQL中正确的使用索引")]),e._v(" "),n("ul",[n("li",[n("strong",[e._v("主键检索")]),e._v("：使用主键检索数据是最快的，因为主键索引是聚集索引结构，叶子节点的数据域中存储了完整的记录")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("select id, name, age from test1 where id = 1000000;\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("ul",[n("li",[n("strong",[e._v("between and范围检索")]),e._v("：如果id字段是主键，使用范围查找可以快速定位目标数据。"),n("code",[e._v("但是如果id的值跨度太大，1所在的页和100万所在页中间有很多页需要遍历，因此所以比较慢，那么使用between and的时候，尽量保证区间跨度不要太大")])])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("select id, name, age from test1 where id between 1 and 2000000;\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("ul",[n("li",[n("strong",[e._v("in检索")]),e._v("：in检索可以优化join连表查询，例如"),n("code",[e._v("基于订单id查询 订单的名称 和 商品的名称")]),e._v("，这个需求需要使用订单表left join 商品表查询。例如 "),n("code",[e._v("select order.id, order.name from order left join good on good.id=order.good_id and order.id < 10;")]),e._v("，那么此时就可以先查询查询订单表，然后订单表中取出good的id列表，采用in的方式到good表检索商品信息，将一条SQL改为两条SQL：")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("select id, name from order where id < 10;  \nselect id, good_name from goods where id in (1, 2, 3, 4);\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br")])]),n("ul",[n("li",[n("strong",[e._v("使用索引覆盖")]),e._v("：SQL "),n("code",[e._v("select * from test1 where name='Petter'")]),e._v("，此时name是非聚集索引，那么第一次检索到主键值后，还需要在聚集索引中获取所有的记录。如果需要获取的字段只有id，那么就可以在select的时候明确指明字段id名称，因为非聚集索引中的叶子节点存储的是字段值和id的值，如果明确指明只要id和name，那么就不会二次检索主键的聚集索引了，在SQL中应该尽量避免二次回表检索")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("select id, name from test1 where name='Petter';\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("ul",[n("li",[n("strong",[e._v("索引下推")]),e._v("：在SQL中，如果要进行模糊匹配和过滤字段的值，并且返回匹配到的字段值，例如"),n("code",[e._v("select * from test1 a where name like 'javacode35%' and sex = 1;")]),e._v("，那么将name和sex字段创建联合索引，这种情况下就不会二次检索主键的聚集索引，在非聚合索引的数据域就存储了id、name、sex的值")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("select id, name, sex from test1 a where name like 'javacode35%' and sex = 1;\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("ul",[n("li",[n("strong",[e._v("数字会使得字符串类型字段的索引失效")]),e._v("：例如下面SQL中，id是字符串类型，使用id=1进行过滤，会使得索引失效")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("select * from test1 where id=1;\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("ul",[n("li",[n("strong",[e._v("函数会使得索引失效")]),e._v("：例如下面SQL中，concat(test1.name,'1')使用了函数之后，name字段的索引树无法定位到数据所在的页，因此只能全表扫描")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("select * from test1 where concat(test1.name,'1') = 'robby1';\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("ul",[n("li",[n("strong",[e._v("运算符使索引无效")]),e._v("：例如下面SQL中，id+1在聚集索引中，无法定位到数据所在的页，因此只能全表扫描")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("select * from test1 a where id+1=2\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("ul",[n("li",[n("strong",[e._v("联合索引可以优化排序")]),e._v("：例如有订单表t_order(id,user_id,addtime,price)，在查询的时候，经常需要查询某个user_id的订单信息，并且按照addtime字段的升序排序，那么正常的流程如果在user_id上创建索引，那么数据检索的过程如下")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("1：走user_id索引，找到记录的的id列表\n\n2：通过id在主键索引中回表检索出整条数据\n\n3：重复上面的操作，获取所有目标记录\n\n4：在内存中对目标记录按照addtime进行排序\n\n\n\n问题：在第4步过程中，如果记录数量非常大，那么在内存中的排序会比较慢的\n如果给user_id和addtime两个字段创建联合索引，那么按照B+Tree的数据结构，叶子节点是按照key值的升序排好顺序的，直接查出来就是排好序的，不需要在内存中再次排序了。如果是排降序，那么直接翻转链表就好了\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br")])]),n("h2",{attrs:{id:"四-小结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#四-小结"}},[e._v("#")]),e._v(" 四：小结")]),e._v(" "),n("h3",{attrs:{id:"一-对比常用的tree结构优劣"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一-对比常用的tree结构优劣"}},[e._v("#")]),e._v(" (一)：对比常用的Tree结构优劣")]),e._v(" "),n("ul",[n("li",[e._v("总结一下各种树解决的问题以及面临的新问题")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("1：二叉查找树(BST)：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表\n\n2：平衡二叉树(AVL)：通过旋转解决了平衡的问题，但是旋转操作效率太低\n\n3：红黑树：通过舍弃严格的平衡和引入红黑节点，解决了AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多\n\n4：B树：通过将二叉树改为多路平衡查找树，解决了树过高的问题\n\n5：B+树：在B树的基础上，将非叶节点改造为不存储数据的纯索引节点，进一步降低了树的高度；此外将叶节点使用指针连接成链表，范围查询更加高效\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br")])]),n("h3",{attrs:{id:"二-使用索引的一些注意点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二-使用索引的一些注意点"}},[e._v("#")]),e._v(" (二)：使用索引的一些注意点")]),e._v(" "),n("ul",[n("li",[e._v("下面小结了一下日常开发过程中，编写SQL和创建索引的建议")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("1：在区分度高的字段上面建立索引可以有效的使用索引，区分度太低，无法有效的利用索引，可能需要扫描所有数据页，此时和不使用索引差不多\n\n2：联合索引注意最左匹配原则：必须按照从左到右的顺序匹配，MySQL会一直向右匹配直到遇到范围查询\n\n3：查询记录的时候，少使用*，尽量去利用索引覆盖，可以减少回表操作，提升效率\n\n4：有些查询可以采用联合索引，进而使用到索引下推，也可以减少回表操作，提升效率\n\n5：禁止对索引字段使用函数、运算符操作，会使索引失效\n\n6：字符串字段和数字比较的时候会使索引无效\n\n7：模糊查询'%值%'会使索引无效，变为全表扫描，但是'值%'这种可以有效利用索引\n\n8：排序中尽量使用到索引字段，这样可以减少排序，提升查询效率\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br"),n("span",{staticClass:"line-number"},[e._v("14")]),n("br"),n("span",{staticClass:"line-number"},[e._v("15")]),n("br")])])])}),[],!1,null,null,null);s.default=t.exports}}]);