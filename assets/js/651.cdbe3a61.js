(window.webpackJsonp=window.webpackJsonp||[]).push([[651],{2772:function(s,t,a){"use strict";a.r(t);var n=a(9),r=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"一-锁的分类对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一-锁的分类对比"}},[s._v("#")]),s._v(" 一：锁的分类对比")]),s._v(" "),a("h3",{attrs:{id:"一-互斥锁与自旋锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一-互斥锁与自旋锁"}},[s._v("#")]),s._v(" (一)：互斥锁与自旋锁")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("互斥锁")]),s._v(" 加锁失败后，线程会释放 CPU ，操作系统调度CPU给其他线程使用")])]),s._v(" "),a("div",{staticClass:"language-javascript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("：互斥锁是一种独占锁，比如当线程 "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("A")]),s._v(" 加锁成功后，此时互斥锁已经被线程 "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("A")]),s._v(" 独占了，只要线程 "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("A")]),s._v(" 没有释放手中的锁，线程 "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("B")]),s._v(" 加锁就会失败，于是就会释放 "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("CPU")]),s._v(" 让给其他线程，既然线程 "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("B")]),s._v(" 释放掉了 "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("CPU")]),s._v("，线程 "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("B")]),s._v(" 加锁的代码就会被阻塞\n\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v("：互斥锁加锁失败时，内核会将线程从用户态切换到内核态，内核会把线程的状态从运行状态设置为睡眠状态，如果锁被释放了，线程从睡眠状态转换为就绪状态。这个过程会有两次线程上下文切换的成本。因此如果锁住的代码执行时间很短，那么就可以选择自旋锁\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("ul",[a("li",[a("strong",[s._v("自旋锁")]),s._v(" 加锁失败后，线程会忙等待，直到它拿到锁。那么如果锁住的代码执行时间很短，就需要使用自旋锁")])]),s._v(" "),a("h3",{attrs:{id:"二-读写锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二-读写锁"}},[s._v("#")]),s._v(" (二)：读写锁")]),s._v(" "),a("ul",[a("li",[s._v("读写锁适用于能明确区分读操作和写操作的场景，读写锁的工作原理如下")])]),s._v(" "),a("div",{staticClass:"language-javascript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("：当 写锁 没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为 读锁 是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据\n\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v("：但是，一旦 写锁 被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("ul",[a("li",[s._v("基于读写锁的原理，因此"),a("strong",[s._v("读写锁在读多写少的场景，能发挥出优势")]),s._v("。那么"),a("strong",[s._v("公平读写锁")]),s._v("比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现饥饿的现象")])]),s._v(" "),a("h3",{attrs:{id:"三-乐观锁与悲观锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三-乐观锁与悲观锁"}},[s._v("#")]),s._v(" (三)：乐观锁与悲观锁")]),s._v(" "),a("ul",[a("li",[a("p",[a("strong",[s._v("互斥锁、自旋锁、读写锁，都是属于悲观锁")]),s._v("，他们认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。")])]),s._v(" "),a("li",[a("p",[a("strong",[s._v("那么如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁")]),s._v("。乐观锁工作方式是：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。"),a("strong",[s._v("乐观锁全程并没有加锁，所以它也叫无锁编程")])])]),s._v(" "),a("li",[a("p",[a("strong",[s._v("那么在在线文档、Git业务中，会使用到乐观锁")]),s._v("，因为我们认为这种业务冲突率比较低，当用户编辑的时候都不加锁，只记录版本号，一旦提交文档，会检查文档当前版本号是否与之前读取的一样，如果一样说明不会造成冲突，直接提交。如果不一样，先更新本地文档，再次提交")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);