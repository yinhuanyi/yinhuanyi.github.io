(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{2175:function(s,t,a){"use strict";a.r(t);var e=a(9),n=Object(e.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"一-微服务概览"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-微服务概览"}},[s._v("#")]),s._v(" 一：微服务概览")]),s._v(" "),e("h3",{attrs:{id:"一-架构思想"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-架构思想"}},[s._v("#")]),s._v(" (一) 架构思想")]),s._v(" "),e("ul",[e("li",[s._v("单体应用架构")])]),s._v(" "),e("p",[e("img",{attrs:{src:a(685),alt:"Alt text"}})]),s._v(" "),e("ul",[e("li",[s._v("SOA：面向服务的架构模式，micro service是SOA的一种最佳实践。微服务满足如下特点")])]),s._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("1：单一的职责：一个服务只需要做好一件事情，数据之间相互隔离，互不干扰，专注做好自己的事情\n\n2：早期职责简单：在开发初期，只需要满足核心API的定义，数据可以先mock，不会影响团队的开发进度，后续业务可以慢慢优化\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("ul",[e("li",[s._v("微服务的定义")])]),s._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("基于当前业务构建，关注的业务单一，服务之间使用轻量级的通信协议，并且部署独立，可以使用不同的编程语言和数据库存储技术，使得整个系统架构之间的开发更为灵活\n\n\n优点：\n\t原子服务\n\t独立进程\n\t服务隔离\n\t去中心化服务治理\n\n缺点：\n\t服务规划和建设的复杂度较高，进程之间的通信一般使用基于RPC框架或者事务消息等，因此需要考虑到消息传递不可达或响应速度较慢的问题  \n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br")])]),e("ul",[e("li",[s._v("下面是一个典型的微服务架构图：不同服务具有独立的数据，服务是通过container运行的，可以选择4核8G的物理机，部署container，使得当物理机宕机或出现故障，对业务的影响较小")])]),s._v(" "),e("p",[e("img",{attrs:{src:a(686),alt:"Alt text"}})]),s._v(" "),e("ul",[e("li",[s._v("基础设施的自动化")])]),s._v(" "),e("div",{staticClass:"language-javascript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("："),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("CICD")]),s._v("：Gitlab "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" Gitlab Hooks "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" K8s\n\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v("：Testing"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" 测试环境、单元测试、"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("API")]),s._v(" 自动化测试\n\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v("：生产环境："),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("K8S")]),s._v("、Prometheus、"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("ELK")]),s._v("、Panel等\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("h3",{attrs:{id:"二-微服务设计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二-微服务设计"}},[s._v("#")]),s._v(" (二) 微服务设计")]),s._v(" "),e("ul",[e("li",[s._v("注意"),e("code",[s._v("前轻后重")]),s._v("，将复杂的数据组装逻辑放在后台做，前端只做展示。新增中间层，用于统一数据传输协议出口，在服务内部进行大量的dataset join操作")])]),s._v(" "),e("p",[e("img",{attrs:{src:a(687),alt:"Alt text"}})]),s._v(" "),e("ul",[e("li",[s._v("此时，从业务架构上看，Backend for Front层是一个单点，那么就需要按照业务进行拆分，架构如下")])]),s._v(" "),e("p",[e("img",{attrs:{src:a(688),alt:"Alt text"}})]),s._v(" "),e("ul",[e("li",[s._v("随着业务越来越复杂，Backend for Front层的安全认证、日志监控、限流熔断等会出现冗余，那么在Backend for Front层之上再加上一层API网关，主要负责数据请求调度、统一认证和鉴权、限流等功能。"),e("code",[s._v("此时的Backend for Front层只负责业务请求数据的组装")]),s._v("，API网关层可以选择Kong或者Envoy")])]),s._v(" "),e("p",[e("img",{attrs:{src:a(689),alt:"Alt text"}})]),s._v(" "),e("ul",[e("li",[e("p",[s._v("在官网的页面首页，是基于Nust.js进行服务器端渲染")])]),s._v(" "),e("li",[e("p",[s._v("在微服务内部结构划分中，例如任务执行的结果会写入到数据库中，查询任务执行的结果需要从数据库的最终结果查询到，那么可以将数据更新操作和数据查询操作拆分，使用canal订阅MySQL的binlog日志数据，服务架构如下")])])]),s._v(" "),e("p",[e("img",{attrs:{src:a(690),alt:"Alt text"}})]),s._v(" "),e("ul",[e("li",[s._v("对于外网请求，微服务架构安全认证的思考")])]),s._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("用户请求先到达四层的SLB，在进入到七层的Nginx，然后进入到API网关，在API网关中完成用户认证，验证用户的access token，如果认证成功会获取到用户的ID，然后将header中的用户ID删除，重新写入一个用户的ID作为key，value就是用户ID的值，并且放在HTTP的header中或者gRPC的metadata中。在BFF层会获取到header或metadata中的用户ID，然后通过传参的方式将用户的ID带给下游的微服务\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("ul",[e("li",[s._v("对于内网请求，微服务架构安全认证的思考")])]),s._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("两个微服务之间，如果做到认证和鉴权。最简单的方式就是下发token，例如A服务给B服务颁发了token，只要token不泄露或者不过期，那么A就知道B是谁，然后再判断B可以请求A的哪些接口\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("h3",{attrs:{id:"三-grpc和服务发现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三-grpc和服务发现"}},[s._v("#")]),s._v(" (三) gRPC和服务发现")]),s._v(" "),e("ul",[e("li",[s._v("Java、C++、Golang、Python常用的RPC框架")])]),s._v(" "),e("div",{staticClass:"language-javascript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[s._v("Java最常用的是Dubbo\n"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("C")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("++")]),s._v("最常用的Thrift\nGolang最常用的是gRPC\nPython最常用的ZeroRPC\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("ul",[e("li",[s._v("gRPC介绍")])]),s._v(" "),e("p",[e("img",{attrs:{src:a(691),alt:"Alt text"}})]),s._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("1：在上图中，ruby的client和Android-Java的client都可以与C++编写的server端通信\n\n2：gRPC是多语言的，满足C#、C++、Dart、Go、Java、Kotlin、Node、Objective-C、PHP、Python、Ruby，从功能上来看，公网请求也可以使用gRPC协议替代HTTP协议，因为gRPC是基于HTTP2.0开发的\n\n3：支持Protocol Buffer和Json序列化  \n\n4：基于pb文件定义服务，通过一个pb文件就可以定义请求的服务名称，请求参数，响应参数，以及数据类型\n\n5：对移动端支持友好，基于HTTP2.0设计，支持双向流、消息头部压缩、单TCP多路复用、服务端数据推送等\n\n6：支持异步和同步的信息交换\n\n7：支持元数据交换，用于认证、追踪 \n\n8：有标准化的状态码\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br")])]),e("ul",[e("li",[e("p",[s._v("gRPC有一个标准的健康检测协议，即主动健康检查health check，当服务端不稳定的时候，客户端可以基于health check感知到，然后在其连接池中将当前的连接关闭，然后从负载均衡中摘除当前服务。当服务端稳定后，会重新加入到负载均衡中")])]),s._v(" "),e("li",[e("p",[s._v("对于微服务中的服务发现而言，"),e("code",[s._v("一般是基于客户端的发现机制")]),s._v("，通过服务端启动的时候，向注册中心注册，客户端就可以从注册中心获取到服务端的IP，从而基于某种负载均衡的算法，实现客户端与服务器端的端到端连接")])]),s._v(" "),e("li",[e("p",[s._v("早期最熟悉的是使用Zookeeper作服务发现，目前较为流行的注册中心有：Eureka、Nacos、Consul等。服务的appid名称一般使用三段式命名法则："),e("code",[s._v("distribute.exec.service")])])])]),s._v(" "),e("h3",{attrs:{id:"四-多集群"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四-多集群"}},[s._v("#")]),s._v(" (四) 多集群")]),s._v(" "),e("ul",[e("li",[s._v("在K8S平台(PaaS平台)，启动两台账户服务，可以取名为cluster01、cluster02，当容器启动的时候，通过环境变量将cluster信息传递到容器内部，使得container知道自己属于哪一套cluster集群。这个环境变量从容器的管理平台设置，通过环境变量到容器，再到容器中的应用程序，应用程序启动的时候，将cluster信息注册到注册中心，以便BBF层服务可以发现到。由于不同的cluster集群使用的cache也是相互隔离的，那么当一个cluster集群宕机后，切换流量到其他集群，其他集群的cache缓存就会被穿透，因此考虑BBF层应用在请求服务的时候，cluster01和cluster02的集群都连接上，那么当其中一个集群宕机之后，切换了流量，那么cache的命中率不会降低，不会出现缓存穿透")])]),s._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("但是这样就会出现一个问题，每一个gRPC客户端会连接所有的service节点，使得长连接导致的内存和CPU开销较高，health check消耗资源高达30%以上。那么可以使用子集算法，从所有的service节点中选择一部分节点进行连接，这个子集算法必须是动态的，需要基于service节点数量的变化而变化\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("h3",{attrs:{id:"五-多租户"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五-多租户"}},[s._v("#")]),s._v(" (五) 多租户")]),s._v(" "),e("ul",[e("li",[s._v("多租户架构是指在一个微服务系统中，允许一类服务，例如账户服务 account service有多个版本共存。租户可以是测试系统、或者金丝雀发布，或者影子系统(全链路压测，压测的是真实的线上环境，不影响生产环境业务)。")])]),s._v(" "),e("p",[e("img",{attrs:{src:a(692),alt:"Alt text"}})]),s._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("多租户架构可以认为是流量源头设置一个tag标签，例如在HTTP请求的header中设置一个请求头color，然后写入到Golang的context.Context上下文中，然后获取Context上下文中的color，基于gRPC负载均衡算法将带有color的流量路由到下游节点中带color信息的节点上，使得测试流量可以调度到测试节点上，正常流量调度到正常的节点上\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("ul",[e("li",[s._v("如果是测试多个节点，例如一个功能的全链路测试，包括Redis和MySQL，那么就需要测试人员对Redis和MySQL灌入数据，然后部署测试节点，同样也可以使用color进行标记节点，然后判断请求流量是否携带color字段，使测试流量可以顺利调度到测试节点")])]),s._v(" "),e("p",[e("img",{attrs:{src:a(693),alt:"Alt text"}})])])}),[],!1,null,null,null);t.default=n.exports},685:function(s,t,a){s.exports=a.p+"assets/img/2022-01-0510.24.55.703ac0b7.png"},686:function(s,t,a){s.exports=a.p+"assets/img/2022-01-0510.55.45.6e976142.png"},687:function(s,t,a){s.exports=a.p+"assets/img/2022-01-0514.57.59.9f83a14e.png"},688:function(s,t,a){s.exports=a.p+"assets/img/2022-01-0515.04.30.4a94e724.png"},689:function(s,t,a){s.exports=a.p+"assets/img/2022-01-0515.24.04.2cc75b2c.png"},690:function(s,t,a){s.exports=a.p+"assets/img/2022-01-0515.57.29.dc1ad0d3.png"},691:function(s,t,a){s.exports=a.p+"assets/img/2022-01-0516.30.43.e1fec8d4.png"},692:function(s,t,a){s.exports=a.p+"assets/img/2022-01-0522.15.48.33faa6f1.png"},693:function(s,t,a){s.exports=a.p+"assets/img/2022-01-0522.39.56.e3fc7a27.png"}}]);