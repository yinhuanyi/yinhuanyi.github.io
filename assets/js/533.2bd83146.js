(window.webpackJsonp=window.webpackJsonp||[]).push([[533],{2522:function(s,e,n){"use strict";n.r(e);var a=n(9),t=Object(a.a)({},(function(){var s=this,e=s.$createElement,n=s._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h2",{attrs:{id:"一-在动态组件上使用-keep-alive"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一-在动态组件上使用-keep-alive"}},[s._v("#")]),s._v(" 一：在动态组件上使用 keep-alive")]),s._v(" "),n("h3",{attrs:{id:"一-在动态组件上使用-keep-alive缓存失活组件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一-在动态组件上使用-keep-alive缓存失活组件"}},[s._v("#")]),s._v(" （一）在动态组件上使用 keep-alive缓存失活组件")]),s._v(" "),n("ul",[n("li",[s._v("当组件在切换的时候，默认之前访问的数据将会被重新渲染，因此会丢失。我们希望当组件切换的时候，失活的组件实例能够被在它们第一次被创建的时候缓存下来")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('\x3c!-- 失活的组件将会被缓存！--\x3e\n<keep-alive>\n  <component v-bind:is="currentTabComponent"></component>\n</keep-alive>\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br")])]),n("h3",{attrs:{id:"二-异步组件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二-异步组件"}},[s._v("#")]),s._v(" （二）异步组件")]),s._v(" "),n("ul",[n("li",[s._v("异步组件指的是：有些组件不是应用第一次启动就被加载，而是用到了在被解析组件的定义，然后将组件缓存起来。"),n("code",[s._v("这种异步组件才可以通过一个工厂函数创建")])])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Vue.component('async-example', function (resolve, reject) {\n  setTimeout(function () {\n    // 向 `resolve` 回调函数传递组件的定义\n    resolve({\n      template: '<div>I am async!</div>'\n    })\n  }, 1000)\n})\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br")])]),n("ul",[n("li",[s._v("当需要使用组件的时候，调用resolve回调函数或者reject(reason) 回调函数。那么如果获取组件取决于用户，一个推荐的做法是将异步组件和 webpack 的 code-splitting 功能一起配合使用")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Vue.component('async-webpack-example', function (resolve) {\n  // 这个特殊的 `require` 语法将会告诉 webpack\n  // 自动将你的构建代码切割成多个包，这些包会通过 Ajax 请求加载\n  require(['./my-async-component'], resolve)\n})\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("ul",[n("li",[s._v("也可以在工厂函数中返回一个 Promise对象，所以把 webpack 2 和 ES2015 语法加在一起，我们可以这样使用动态导入：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("Vue.component(\n  'async-webpack-example',\n  // 这个动态导入会返回一个 `Promise` 对象。\n  () => import('./my-async-component')\n)\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("ul",[n("li",[s._v("当使用局部注册的时候，你也可以直接提供一个返回 Promise 的函数：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("new Vue({\n  components: {\n    'my-component': () => import('./my-async-component')\n  }\n})\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("h3",{attrs:{id:"三-处理加载状态"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三-处理加载状态"}},[s._v("#")]),s._v(" （三）处理加载状态")]),s._v(" "),n("ul",[n("li",[s._v("这里的异步组件工厂函数也可以返回一个如下格式的对象：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("const AsyncComponent = () => ({\n  // 需要加载的组件 (应该是一个 `Promise` 对象)\n  component: import('./MyComponent.vue'),\n  // 异步组件加载时使用的组件\n  loading: LoadingComponent,\n  // 加载失败时使用的组件\n  error: ErrorComponent,\n  // 展示加载时组件的延时时间。默认值是 200 (毫秒)\n  delay: 200,\n  // 如果提供了超时时间且组件加载也超时了，\n  // 则使用加载失败时使用的组件。默认值是：`Infinity`\n  timeout: 3000\n})\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br")])])])}),[],!1,null,null,null);e.default=t.exports}}]);