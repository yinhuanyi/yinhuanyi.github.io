(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{2168:function(s,t,a){"use strict";a.r(t);var e=a(9),n=Object(e.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"一-memcached"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-memcached"}},[s._v("#")]),s._v(" 一：Memcached")]),s._v(" "),e("h3",{attrs:{id:"一-memcached基本概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-memcached基本概念"}},[s._v("#")]),s._v(" (一) Memcached基本概念")]),s._v(" "),e("ul",[e("li",[e("strong",[s._v("Memcached提供了简单的K/V存储，Value大小不超过1MB")]),s._v("，由于Memcached是多线程的应用，那么Memcached的吞吐能力会比Redis强，Memcached经常作为大文本和简单的KV结构使用")])]),s._v(" "),e("h3",{attrs:{id:"二-memcached的内存管理与删除机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二-memcached的内存管理与删除机制"}},[s._v("#")]),s._v(" (二) Memcached的内存管理与删除机制")]),s._v(" "),e("ul",[e("li",[s._v("Memcached的内存管理机制与系统内存管理机制类似，"),e("strong",[s._v("为了减小内存的碎片化的负面影响")]),s._v("，"),e("strong",[s._v("Memcached 用 Slab Allocator 机制来管理内存")]),s._v("，"),e("code",[s._v("Slab Allocator")]),s._v(" 内存管理的方式如下")])]),s._v(" "),e("p",[e("img",{attrs:{src:a(642),alt:"Alt text"}})]),s._v(" "),e("div",{staticClass:"language-javascript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("：预先把Memcached的内存划分成数个 Slab Class 仓库（每个Slab Class大小为"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("MB"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("，每个Slab Class又被切分为不同大小的Chunk\n\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v("：当需要存储数据的时候，判断数据的大小，选择合适的Slab Class中的Chunk存储\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("h3",{attrs:{id:"三-memcached如何选择合适的chunk"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三-memcached如何选择合适的chunk"}},[s._v("#")]),s._v(" (三) Memcached如何选择合适的chunk")]),s._v(" "),e("p",[e("img",{attrs:{src:a(643),alt:"Alt text"}})]),s._v(" "),e("ul",[e("li",[s._v("Memcached 判断需要存储的数据大小，"),e("strong",[s._v("基于内部记录的每个Slab Class空闲的Chunk列表")]),s._v("，"),e("strong",[s._v("选择合适的Chunk存储数据")])])]),s._v(" "),e("h3",{attrs:{id:"四-固定大小的chunk带来的内存浪费"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四-固定大小的chunk带来的内存浪费"}},[s._v("#")]),s._v(" (四) 固定大小的chunk带来的内存浪费")]),s._v(" "),e("p",[e("img",{attrs:{src:a(644),alt:"Alt text"}})]),s._v(" "),e("ul",[e("li",[s._v("由于在Slab Class机制中，分配的 Chunk 的大小是"),e("strong",[s._v("固定")]),s._v("的，对于特定的Item数据，会造成内存空间的浪费。例如将 100Bytes的Item存储到122Bytes的Chunk中，剩余的22Bytes就浪费了。虽然无法自定义Chunk的大小，但是可以设置各 Slab Class 中 Chunk 大小的增长速度，这个参数叫做 "),e("strong",[s._v("增长因子")]),s._v("，即"),e("code",[s._v("Grow Factor")])])]),s._v(" "),e("h3",{attrs:{id:"五-grow-factor-增长因子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五-grow-factor-增长因子"}},[s._v("#")]),s._v(" (五) Grow Factor 增长因子")]),s._v(" "),e("p",[e("img",{attrs:{src:a(645),alt:"Alt text"}})]),s._v(" "),e("ul",[e("li",[s._v("Memcached 在启动时"),e("strong",[s._v("可以通过 -f 选项指定 Grow Factor 因子")]),s._v("，默认是1.25")])]),s._v(" "),e("h3",{attrs:{id:"六-memcached的lru删除机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#六-memcached的lru删除机制"}},[s._v("#")]),s._v(" (六) Memcached的LRU删除机制")]),s._v(" "),e("ul",[e("li",[s._v("如果以122Bytes大小的Chunk举例，如果122Bytes的Chunk都满了，此时有一个Item为120Bytes需要存储，Memcached不会找144Bytes的空Chunk存储这个Item，而是从有数据的122Bytes的Chunk中，基于LRU 淘汰机制删除以前的数据，将新的数据存储进来")])]),s._v(" "),e("h3",{attrs:{id:"七-memcached的集群"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#七-memcached的集群"}},[s._v("#")]),s._v(" (七) Memcached的集群")]),s._v(" "),e("ul",[e("li",[s._v("Memcached没有集群方案，在业务设计中，如果需要存储30G大小的数据，一般会设置多个Memcachd节点，通过对key做一致性hash算法，获取到Memcachd集群节点的IP，然后将数据存储到对应的节点中")])]),s._v(" "),e("h2",{attrs:{id:"二-redis"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二-redis"}},[s._v("#")]),s._v(" 二：Redis")]),s._v(" "),e("h3",{attrs:{id:"一-redis基本概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-redis基本概念"}},[s._v("#")]),s._v(" (一)：Redis基本概念")]),s._v(" "),e("ul",[e("li",[s._v("新版本的Redis在处理网络I/O和协议解析方面使用了多线程，但是在命令执行依然是单线程")])]),s._v(" "),e("h3",{attrs:{id:"二-redis在微服务中正确的使用方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二-redis在微服务中正确的使用方式"}},[s._v("#")]),s._v(" (二)：Redis在微服务中正确的使用方式")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("Redis服务在微服务中都应该是独立的，不能与传统架构一样，让多个微服务共享一个Redis集群。每个Redis服务都是相互隔离的，不会相互影响，吞吐能力也会提升。当Redis内存不断增加后，会给一个Redis服务设置多个节点，那么此时就是给Redis做Sharding")])]),s._v(" "),e("li",[e("p",[s._v("由于在Redis客户端维护Redis Sharding的逻辑比较繁琐，那么可以使用Redis的Proxy代理。都是后面出现了Redis集群的时候，就不需要Proxy代理了，Redis集群会自动完成Sharding机制")])])]),s._v(" "),e("h3",{attrs:{id:"三-redis集群的负载均衡过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三-redis集群的负载均衡过程"}},[s._v("#")]),s._v(" (三)：Redis集群的负载均衡过程")]),s._v(" "),e("ul",[e("li",[s._v("Redis集群中每个redis实例都负责接管一部分槽，总槽数为：16384，如果有3台master，那么每台负责5461个槽（16384/3)")])]),s._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[s._v("redis节点")]),s._v(" "),e("th",{staticStyle:{"text-align":"center"}},[s._v("负责的槽位")])])]),s._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[s._v("node1")]),s._v(" "),e("td",{staticStyle:{"text-align":"center"}},[s._v("0-5461")])]),s._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[s._v("node2")]),s._v(" "),e("td",{staticStyle:{"text-align":"center"}},[s._v("5461-10922")])]),s._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[s._v("node3")]),s._v(" "),e("td",{staticStyle:{"text-align":"center"}},[s._v("10922-16383")])])])]),s._v(" "),e("ul",[e("li",[s._v("当redis客户端设置值时，会拿key进行CRC16算法，然后 跟16384取模，得到的就是落在哪个槽位，根据上面表格就得出在哪台节点上")])]),s._v(" "),e("div",{staticClass:"language-javascript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[s._v("slot "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("CRC16")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("key"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("&")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("16383")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("h3",{attrs:{id:"四-热点数据负载均衡的解决方案-有限负载一致性哈希"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四-热点数据负载均衡的解决方案-有限负载一致性哈希"}},[s._v("#")]),s._v(" (四)：热点数据负载均衡的解决方案：有限负载一致性哈希")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("Redis集群基于CRC16算法做一致性hash后，并没有解决热点问题："),e("strong",[s._v("当有部分资源是热点资源，请求基于一致性哈希算法调度到某一个节点上，那么这个节点需要处理大量请求，出现负载非常不均的情况")])])]),s._v(" "),e("li",[e("p",[e("strong",[s._v("有限负载一致性哈希算法")]),s._v("的主要思想是：根据当前负载情况对所有节点限制一个最大负载，在一致性哈希中对 hash 环进行查找时将跳过达到最大负载限制的节点，通过把过载的请求转移到其他节点上来解决热点和不均衡问题")])])]),s._v(" "),e("div",{staticClass:"language-javascript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("R")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" 当前所有节点的总负载（正在处理的总请求数）\n\n"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("T")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" 节点总个数\n\n"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("L")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" 当前所有节点的平均负载，"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("L")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("R")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("T")]),s._v("\n\nε"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" 一个参数用于表示在平均负载的基础上能够承受的额外负载上限，可以按照实际需求进行设置（这个值推荐设置为 "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("0.25")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("~")]),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("）\n\n"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("M")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" 节点的最大负载上限\n\n"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("M")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("L")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v("ε"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("R")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v("ε"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("T")]),s._v("\n\n当 ε 的值是 "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" 的时候，就实现了最少连接策略的效果\n当 ε 的值是无穷大的时候，就是一致性哈希策略\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br")])]),e("ul",[e("li",[e("p",[e("strong",[s._v("那么在哈希环中进行进行节点查找时，增加检查匹配的节点的负载（正在处理的请求数）是否达到负载上限 M 的操作，如果达到了上限则跳过当前节点继续往后查找")]),s._v("。可以发现 "),e("strong",[s._v("有限负载一致性哈希 结合了 最少连接策略 和一致性哈希 策略各自的优点，即平衡了负载又兼顾了一致性哈希，并且还可以通过调整转化为最少请求策略或一致性哈希策略")])])]),s._v(" "),e("li",[e("p",[e("strong",[s._v("节点权重问题")])])])]),s._v(" "),e("div",{staticClass:"language-javascript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[s._v("上面的方法是没有区分节点权重的，如果要支持节点权重的话，需要做一点改动"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v("\n\n"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("R")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" 当前所有节点的总负载（正在处理的总请求数）\n"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("T")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" 所有节点的权重总和\n"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("L")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" 当前所有节点的平均负载（基于权重的平均负载）\n"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("L")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("R")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("T")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("W")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" 当前节点的权重值\nε"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" 一个参数用于表示在平均负载的基础上能够承受的额外负载上限。\n"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("M")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" 节点的最大负载上限\n"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("M")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("W")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("L")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v("ε"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("W")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("R")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v("ε"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("T")]),s._v("\n\n一致性哈希中进行节点查找时，增加检查匹配的节点的负载（正在处理的请求数）是否达到负载上限 "),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("M")]),s._v(" 的操作，如果达到了上限则跳过当前节点继续往后查找\n\n可以看到主要区别是算平均负载的时候是基于节点的权重和来计算的，算负载上限的时候是按权重比来计算的\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br")])]),e("h3",{attrs:{id:"五-数据一致性问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五-数据一致性问题"}},[s._v("#")]),s._v(" (五)：数据一致性问题")]),s._v(" "),e("ul",[e("li",[s._v("在 Cache Aside 的架构中，会有很多中情况出现数据不一致的现象，例如")])]),s._v(" "),e("div",{staticClass:"language-javascript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("：读缓存 Cache Miss，再读"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("DB")]),s._v("，获取数据，回填到缓存中，如果回填失败了怎么办？\n\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v("：修改"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("DB")]),s._v("数据后，同步更新缓存，更新缓存的不成功怎么办？重试？重试多少次？\n\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v("：在处理数据写入的请求时，写入数据到Kafka，Job服务从Kafka消费数据，写入到缓存和"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("DB")]),s._v("不成功怎么办？\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("ul",[e("li",[s._v("一般在解决缓存数据与DB数据一致性的时候，会使用一个Job Service服务做兜底操作，模型如下：通过Job Service读取binlog日志(可以使用阿里的Canal服务)，然后再将缓存回填到Redis中，这样就保证了Redis的数据都是最新数据")])]),s._v(" "),e("p",[e("img",{attrs:{src:a(646),alt:"Alt text"}})]),s._v(" "),e("ul",[e("li",[s._v("但是这里还是会有问题，"),e("strong",[s._v("可能在高并发场景下，会出现【Happens Before】的问题")]),s._v("，例如下面这个案例："),e("strong",[s._v("v1的回填操作覆盖了缓存的最新数据v2，使得此时的缓存数据是脏数据")])])]),s._v(" "),e("p",[e("img",{attrs:{src:a(647),alt:"Alt text"}})]),s._v(" "),e("div",{staticClass:"language-javascript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("：此时有一个读请求和一个写请求的并发操作\n\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v("：当从缓存中读取v1的时候Miss，再读取"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("DB")]),s._v("中的v1，但是此时回填缓存出现了"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("GC")]),s._v("卡顿\n\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v("：此时写操作先写入v2到"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("DB")]),s._v("，然后将v2写入到缓存\n\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("4")]),s._v("：当v2写入到缓存后，"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("GC")]),s._v("卡顿完成，写v1到缓存，那么v1就覆盖了v2\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br")])]),e("ul",[e("li",[s._v("那么有不有办法让Cache Miss的回填操作不覆盖最新的数据呢？那么就需要使用到Redis的 "),e("strong",[s._v("setnx命令")]),s._v(" 了，"),e("strong",[s._v("setnx命令是当数据不存在的时候才设置key的值")]),s._v("。因此当v2写入缓存后，基于setnx回填v1的时候，就不会覆盖v2的值了")])]),s._v(" "),e("h3",{attrs:{id:"六-缓存穿透解决方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#六-缓存穿透解决方案"}},[s._v("#")]),s._v(" (六)：缓存穿透解决方案")]),s._v(" "),e("ul",[e("li",[s._v("singlefly")])]),s._v(" "),e("div",{staticClass:"language-javascript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[s._v("在Cache Miss的时候，基于singlefly库，可以归并查询请求\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("ul",[e("li",[s._v("分布式锁")])]),s._v(" "),e("div",{staticClass:"language-javascript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[s._v("设置一个lock key，只有一个goroutine可以获取到锁，获取到锁的goroutine执行"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("DB")]),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("查询操作")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("回源操作"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("，其他的goroutine都轮询获取这个lock key，获取不到锁就去查询缓存，缓存的key存在即可返回，如果不存在继续竞争锁\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("ul",[e("li",[s._v("队列 + singlefly")])]),s._v(" "),e("div",{staticClass:"language-javascript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[s._v("如果Cache Miss的时候，基于singlefly库，可以归并查询请求。并且给消息中间件投递一个key，基于Job服务消费中间件的key，基于key从"),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("DB")]),s._v("获取key对应的数据，回填到Cache中\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("h3",{attrs:{id:"七-缓存使用技巧"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#七-缓存使用技巧"}},[s._v("#")]),s._v(" (七)：缓存使用技巧")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("1："),e("strong",[s._v("在保证易读性和空间区分的前提下，key设置需要尽可能小，进而减少内存占用")]),s._v("：Redis的value可以使用int类型，就不用string类型，对于小于N的value，Redis内部有sharded_object缓存")])]),s._v(" "),e("li",[e("p",[s._v("2："),e("strong",[s._v("对key进行拆分")]),s._v("：拆分key的目的是使得Redis节点内存占用均匀，避免单节点请求过热")])]),s._v(" "),e("li",[e("p",[s._v("3："),e("strong",[s._v("设置空缓存")]),s._v('：value在DB为nil的数据或者为“”数据，应该设置缓存也为空或者""，避免每次请求都Cache Miss，请求直接打到DB')])]),s._v(" "),e("li",[e("p",[s._v("4："),e("strong",[s._v("序列化使用protobuf")]),s._v("：尽可能减少数据包的size大小")])]),s._v(" "),e("li",[e("p",[s._v("5："),e("strong",[s._v("BITSET类型")]),s._v("：存储每日登录用户，例如签到。单个标记位置类型为boolean")])]),s._v(" "),e("li",[e("p",[s._v("6："),e("strong",[s._v("List 类型")]),s._v("：用于抽奖池，顶弹幕")])]),s._v(" "),e("li",[e("p",[s._v("7："),e("strong",[s._v("SortedSet类型")]),s._v("：用于翻页、排序、有序集合，避免zrange或者zrevrange返回的数据集合过大")])]),s._v(" "),e("li",[e("p",[s._v("8："),e("strong",[s._v("尽可能使用 Pipeline命令")]),s._v("：降低每个命令的网络往返时间")])])]),s._v(" "),e("h2",{attrs:{id:"三-分布式事务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三-分布式事务"}},[s._v("#")]),s._v(" 三：分布式事务")]),s._v(" "),e("h3",{attrs:{id:"一-在单库中的事务处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-在单库中的事务处理"}},[s._v("#")]),s._v(" (一)：在单库中的事务处理")]),s._v(" "),e("ul",[e("li",[s._v("在单库中的事务处理非常简单，只需要在一个事务中去修改表的记录即可。例如下面这个例子是支付宝和余额宝转账的例子，直接在一个transaction中，执行这个两条SQL语句即可")])]),s._v(" "),e("div",{staticClass:"language-javascript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[s._v("用户user_id "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("，将支付宝的"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("10000")]),s._v("元转账到余额宝，需要两个步骤：\n\nupdate 支付宝表 "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("set")]),s._v(" amount "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" amount "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("10000")]),s._v(" where user_id"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\nupdate 余额宝表 "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("set")]),s._v(" amount "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" amount "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("10000")]),s._v(" where user_id"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("h3",{attrs:{id:"二-分布式业务事务处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二-分布式业务事务处理"}},[s._v("#")]),s._v(" (二)：分布式业务事务处理")]),s._v(" "),e("p",[e("img",{attrs:{src:a(648),alt:"Alt text"}})]),s._v(" "),e("ul",[e("li",[s._v("上图"),e("strong",[s._v("在分布式业务事务中，要解决事务消息的可靠性存储，实际上就是解决MySQL数据库与事务消息存储的数据一致性问题")]),s._v("。事务消息一旦被可靠性的持久化，那么分布式事务就变为了最终一致性，消息的消费才能保证最终业务数据的完整性，那么就需要尽可能的将事务消息传递到下游服务中，只有事务消息被正确消费后，整个交易才算完整")])]),s._v(" "),e("p",[e("img",{attrs:{src:a(649),alt:"Alt text"}})]),s._v(" "),e("ul",[e("li",[s._v("上图"),e("strong",[s._v("在开发订单商品系统的时候")]),s._v("，一般会在支付宝的回调页面和接口里面 解密参数，如果用户支付成功，那么更新商品的交易状态，将订单更新为付款成功。只有在回调页面中输出了success字样且有交易成功的状态码，支付宝才会停止回调请求，否则会隔一段时间向客户方发起回调请求，直到输出success字样为止")])]),s._v(" "),e("p",[e("img",{attrs:{src:a(650),alt:"Alt text"}})]),s._v(" "),e("ul",[e("li",[s._v("上图在支付宝转账到余额宝过程中：支付宝在支付宝表扣款amount的同时，也会记录一条message数据，这个message数据与支付宝资产数据在同一个数据库实例中。那么只需要开启一个事务完成这两个操作即可。这个事务操作可以保证的是支付宝账户被扣了钱，扣钱的历史记录可以存储下来。当事务提交成功以后，那么就需要将消息通知到余额宝，当余额宝处理成功后，发送余额宝处理成功消息，支付宝收到消息后就会删除该message记录")])]),s._v(" "),e("div",{staticClass:"language-javascript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[s._v("Begin transaction\n\tupdate 支付宝表 "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("set")]),s._v(" amount "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" amount "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("10000")]),s._v(" where user_id "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\tinsert into "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("message")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("user_id"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" amount"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" status"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("values")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("10000")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\nEnd  transaction\nCommit\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("p",[e("img",{attrs:{src:a(651),alt:"Alt text"}})]),s._v(" "),e("ul",[e("li",[s._v("上图中，创建一个Pay Job服务，定时的查询message表，把status=1的消息查询出来，可以按照自增id排序，保证顺序消费message数据。"),e("code",[s._v("可以将message记录publish到消息队列，然后Balance Service服务comumer消息队列中的消息")]),s._v("，或者Pay Job服务直接调用Balance Service的接口。但是这种定时从message表获取消息记录的方式有一点问题："),e("strong",[s._v("如果查询的message频率较高，那么对DB的压力较大，如果查询message记录频率较低，那么延时就比较高。这种方案适合在交易量不大的情况下使用")])])]),s._v(" "),e("p",[e("img",{attrs:{src:a(652),alt:"Alt text"}})]),s._v(" "),e("ul",[e("li",[s._v("上图"),e("strong",[s._v("为了解决上述 定时查询message表的问题")]),s._v("，可以使用Canal订阅message表的变更，把message表作为一个交易流水表， 通过canal将变更数据发送到Kafka消息队列，然后Balance Service消费Kafka的数据，将数据写入到余额宝表中")])]),s._v(" "),e("h3",{attrs:{id:"三-分布式业务的幂等性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三-分布式业务的幂等性"}},[s._v("#")]),s._v(" (三)：分布式业务的幂等性")]),s._v(" "),e("ul",[e("li",[s._v("在分布式事务中，有一个必须要考虑的问题，就是"),e("strong",[s._v("消息的重复消费")]),s._v("，如果Balance Service消费了Kafka中的数据，并且本地事务执行成功，但是反馈Kafka的offset超时了，此时Kafka会认为消息没有被成功消费，那么当前消息就会被Balance Service再次消费，使得本地事务再次执行，那么余额宝表的amount字段就增加了20000")])]),s._v(" "),e("p",[e("img",{attrs:{src:a(653),alt:"Alt text"}})]),s._v(" "),e("div",{staticClass:"language-javascript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" msg "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("in")]),s._v(" kafka"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v("\n\tBegin Transaction\n\t\tselect "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("count")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("id"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("as")]),s._v(" cnt from msg_apply where id"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("msg"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("msg_id\n\t\t"),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" cnt "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v("\n\t\t\tupdate 余额宝表 "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("set")]),s._v(" amount "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" amount "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("10000")]),s._v(" where user_id "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\t\t\tinsert into "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("msg_apply")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("id"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("values")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("msg"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("msg_id"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\tEnd Transaction\n\tCommit"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\t\t\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br")])]),e("ul",[e("li",[s._v("为了解决这个问题，那么就需要在余额宝的数据库中，创建一张msg_apply表，这张msg_apply表记录了每个消息消费的情况，"),e("strong",[s._v("Balance Service每次消费消息的时候，会先在msg_apply表中查询当前消息的msg_id是否存在，如果不存在说明这条消息没有消费过，那么就需要更新余额宝表，然后将msg_id写入到msg_apply表中，如果msg_id存在，那么直接跳过丢弃这条消息即可")])])]),s._v(" "),e("h3",{attrs:{id:"四-分布式业务的2pc-两阶段提交协议和rocketmq事务消息"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四-分布式业务的2pc-两阶段提交协议和rocketmq事务消息"}},[s._v("#")]),s._v(" (四)：分布式业务的2PC 两阶段提交协议和RocketMQ事务消息")]),s._v(" "),e("ul",[e("li",[s._v("在MySQL中存在两阶段提交协议保证数据的强一致性，会涉及到两种角色："),e("strong",[s._v("协调者")]),s._v(" 和 "),e("strong",[s._v("事务参与者")]),s._v("。协调者协调所有分布式原子事务参与者，并决定提交或回滚，当 2PC 的最后一步完成之后，协调器执行协议，参与者根据本地事务能够成功完成回复同意提交事务或者回滚事务。2PC的执行过程有两个步骤：")])]),s._v(" "),e("div",{staticClass:"language-javascript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("：prepare 阶段\n\t协调者将通知事务参与者准备提交或取消事务，然后进入表决过程，在表决过程中，事务参与者参与者将告知协调者自己的决策 "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("同意")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("本地作业执行成功"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" 或 "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("取消")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("本地作业执行故障"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v("：commit 阶段\n\t协调者将基于第一个阶段的投票结果进行决策：提交或取消，并且通知所有的事务参与者，那么各个事务参与者就根据协调者的决策进行提交或回滚\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("ul",[e("li",[s._v("2PC能够解决很多的临时性系统故障，被广泛地使用，在分布式事务中可以应用2PC算法来解决数据一致性问题。在RocketMQ中，发送事务消息就是用了2PC的机制。")])]),s._v(" "),e("p",[e("img",{attrs:{src:a(654),alt:"Alt text"}})]),s._v(" "),e("ul",[e("li",[s._v("在RocketMQ的事务消息发送过程中，引入了一个"),e("strong",[s._v("半消息概念")]),s._v("，其实就是prepare消息。"),e("strong",[s._v("事务消息保证了业务发送方和MQ消息的最终一致性，其本质是通过半消息(prepare消息和commit消息)的方式把 分布式事务 放在MQ端来处理")]),s._v("，发送方 "),e("strong",[s._v("发送事务消息到RocketMQ的过程如下")])])]),s._v(" "),e("div",{staticClass:"language-javascript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("：发送方先发送半消息到RocketMQ\n\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v("：RocketMQ通知发送方，半消息发送成功\n\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v("：发送方执行本地事务\n\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("4")]),s._v("：根据本地事务执行的结果，发送方给RocketMQ发送 Commit 或 Rollback 通知\n\t"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("4.1")]),s._v("：如果Commit 或 Rollback 通知发送失败，那么RocketMQ会回查发送方的事务状态\n\t"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("4.2")]),s._v("：发送方检查本地的事务执行状态\n\t"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("4.3")]),s._v("：根据本地事务执行状态的结果，向RocketMQ发送Commit 或 Rollback 通知\n\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("5.1")]),s._v("：RocketMQ如果收到的是 Commit 通知，那么将半消息标记为可投递状态，消费者最终可以从RocketMQ消费此消息\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("5.2")]),s._v("：RocketMQ如果收到的是 Rollback 通知，那么直接删除半消息，消费者将不会消费到这条消息\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br")])]),e("ul",[e("li",[e("strong",[s._v("那么在消费者端，从RocketMQ接收到消息，执行本地事务，且需要保证消息的幂等性，防止消息被重复消费")]),s._v("。然后消费者再将本地事务执行的结果反馈给RocketMQ，如果RocketMQ没有收到反馈结果，那么会重新发送消息。"),e("strong",[s._v("如果消费者本地事务一直执行失败，那么就需要人工解决，通过日志查看一下，执行本地事务的SQL语句，手动处理这个本地事务。RocketMQ没有提供事务回滚的机制，因为整个分布式事务回滚非常复杂，考虑的因素非常多")])])]),s._v(" "),e("h3",{attrs:{id:"五-分布式事务-tcc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五-分布式事务-tcc"}},[s._v("#")]),s._v(" (五)：分布式事务 TCC")]),s._v(" "),e("ul",[e("li",[s._v("TCC是Try、Confirm、Cancel的缩写，TCC要求每个分支事务实现三个操作：预处理Try、确认Confirm、撤销Cancel")])])])}),[],!1,null,null,null);t.default=n.exports},642:function(s,t,a){s.exports=a.p+"assets/img/2022-03-1023.03.19.8d2582c7.png"},643:function(s,t,a){s.exports=a.p+"assets/img/2022-03-1023.07.49.661d9e78.png"},644:function(s,t,a){s.exports=a.p+"assets/img/2022-03-1023.16.15.d136e6c4.png"},645:function(s,t,a){s.exports=a.p+"assets/img/2022-03-1023.27.40.738ccc08.png"},646:function(s,t,a){s.exports=a.p+"assets/img/2022-03-1111.44.14.e08063e3.png"},647:function(s,t,a){s.exports=a.p+"assets/img/2022-03-1112.14.03.ec68871b.png"},648:function(s,t,a){s.exports=a.p+"assets/img/2022-03-1117.55.20.2238fde8.png"},649:function(s,t,a){s.exports=a.p+"assets/img/2022-03-1118.05.24.65dcdd60.png"},650:function(s,t,a){s.exports=a.p+"assets/img/2022-03-1119.34.24.bb335d67.png"},651:function(s,t,a){s.exports=a.p+"assets/img/2022-03-1120.12.46.40b0b7cf.png"},652:function(s,t,a){s.exports=a.p+"assets/img/2022-03-1213.46.30.9e6b7bbd.png"},653:function(s,t,a){s.exports=a.p+"assets/img/2022-03-1214.34.37.66c52df8.png"},654:function(s,t,a){s.exports=a.p+"assets/img/2022-03-1215.44.57.5bff108c.png"}}]);