(window.webpackJsonp=window.webpackJsonp||[]).push([[193],{2391:function(s,t,a){"use strict";a.r(t);var e=a(9),n=Object(e.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"一-python-gil"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-python-gil"}},[s._v("#")]),s._v(" 一：Python GIL")]),s._v(" "),e("h3",{attrs:{id:"一-为什么要有锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-为什么要有锁"}},[s._v("#")]),s._v(" (一)： 为什么要有锁")]),s._v(" "),e("ul",[e("li",[s._v("为什么要有锁")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("锁的意义用于保护临界资源访问状态\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("ul",[e("li",[s._v("临界资源")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("临界资源指的是：一些虽然作为共享资源，但是又不能被多个线程共同访问的共享资源。当有进程在使用临界资源时，其他进程必须依据操作系统的同步机制等待占用共享资源的进程释放资源，才能有资格竞争占用资源\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("ul",[e("li",[s._v("Python GIL的意义")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("保证了Python解释器的正确运行\n使得Python语言编码的过程中，无需考虑多余加锁操作\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("h3",{attrs:{id:"二-为什么多线程可以提高i-o密集型任务的效率-但是不能提升cpu密集型任务的效率"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二-为什么多线程可以提高i-o密集型任务的效率-但是不能提升cpu密集型任务的效率"}},[s._v("#")]),s._v(" (二)：为什么多线程可以提高I/O密集型任务的效率，但是不能提升CPU密集型任务的效率")]),s._v(" "),e("ul",[e("li",[s._v("CPU密集型任务")])]),s._v(" "),e("p",[e("img",{attrs:{src:a(953),alt:"Alt text"}})]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("    3个线程在运行CPU密集型任务过程中，每5毫秒Python虚拟机就会强行释放GIL，使得多个线程再次重新竞争，但是无论哪个线程竞争到了GIL锁，同一时间内只能是一个线程在运行。因此线程越多，线程切换和GIL的申请与释放就越平凡，导致多线程运行效率低于单线程\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("ul",[e("li",[s._v("I/O密集型任务")])]),s._v(" "),e("p",[e("img",{attrs:{src:a(954),alt:"Alt text"}})]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("    在I/O密集型任务中，其实多个线程一样也需要竞争申请GIL锁，但是如果其中有线程任务处于I/O等待过程中，线程会自动释放自己的GIL锁，使得其他线程能够竞争到GIL锁。因此多线程屏蔽了I/O等待时间，使得I/O任务效率提升\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])])])}),[],!1,null,null,null);t.default=n.exports},953:function(s,t,a){s.exports=a.p+"assets/img/2021-02-143.47.21.61b9d65b.png"},954:function(s,t,a){s.exports=a.p+"assets/img/2021-02-144.03.02.2b041e1a.png"}}]);