(window.webpackJsonp=window.webpackJsonp||[]).push([[469],{2403:function(a,s,e){"use strict";e.r(s);var t=e(9),n=Object(t.a)({},(function(){var a=this,s=a.$createElement,e=a._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h3",{attrs:{id:"一-django中的migrate的基本原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-django中的migrate的基本原理"}},[a._v("#")]),a._v(" （一）"),e("strong",[e("code",[a._v("Django中的migrate的基本原理")])])]),a._v(" "),e("ul",[e("li",[e("p",[a._v("1：执行"),e("code",[a._v("python manage.py makemigrations Assets")]),a._v("会在migrations目录下生成0001_initial.py版本控制文件")])]),a._v(" "),e("li",[e("p",[a._v("2：执行"),e("code",[a._v("python manage.py migrate Assets")]),a._v("会做4件事")])])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("1: 迁移判定：将你的项目中所有未迁移的变动文件进行迁移。此时Django会查询django_migrations表，决定执行Assets的migrations目录下哪个py文件。执行完毕后，会生产一条记录，记录执行过的py文件的文件名\n\n2：迁移映射关系：在django_content_type中生成APP名称与Model名称的对应关系\n\n3：迁移权限：在auth_permission表生成Model的权限记录\n\n4：执行迁移：在数据库中生成数据表\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br")])]),e("ul",[e("li",[e("p",[a._v("如果在执行"),e("code",[a._v("python manage.py migrate Assets")]),a._v("的时候, 发现有些表已经存在了，那么此时会报错。因此只需要执行"),e("code",[a._v("migrate --fake")]),a._v("即可，"),e("code",[a._v("migrate --fake")]),a._v("会执行上面的第一步，也就是在django_migrations表中生成一条记录")])]),a._v(" "),e("li",[e("p",[e("code",[a._v("migrate --fake-initial")]),a._v(": 会执行前面1，2，3步，不会生成实际的数据表")])])])])}),[],!1,null,null,null);s.default=n.exports}}]);